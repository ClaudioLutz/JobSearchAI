<?xml version="1.0" encoding="UTF-8"?>
<story-context id="bmad/bmm/workflows/4-implementation/story-context" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.4</storyId>
    <title>Application Queue Integration Bridge</title>
    <status>Draft</status>
    <generatedAt>2025-10-16T18:24:00Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>Documentation/Stories/story-1.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>job applicant using JobSearchAI</asA>
    <iWant>an automated bridge that connects my matched jobs and generated motivation letters to the application queue</iWant>
    <soThat>I can efficiently review and send multiple applications without manual file manipulation</soThat>
    
    <tasks>
      <task id="1" title="Create URL Utilities" ac="AC-2">
        <subtask>Create utils/url_utils.py file</subtask>
        <subtask>Implement URLNormalizer class with to_full_url(), normalize_for_comparison(), extract_job_id() methods</subtask>
        <subtask>Write unit tests for URL utilities</subtask>
        <subtask>Test with various URL formats from ostjob.ch</subtask>
      </task>
      
      <task id="2" title="Create Application Context Data Structure" ac="AC-1">
        <subtask>Create models/application_context.py file</subtask>
        <subtask>Define ApplicationContext dataclass with all required fields</subtask>
        <subtask>Implement to_queue_application() transformation method</subtask>
        <subtask>Add unique ID generation using uuid.uuid4()</subtask>
        <subtask>Add validation logic within transformation</subtask>
        <subtask>Write unit tests for ApplicationContext</subtask>
      </task>
      
      <task id="3" title="Create Validation Utilities" ac="AC-6">
        <subtask>Create utils/queue_validation.py file</subtask>
        <subtask>Implement ApplicationValidator class</subtask>
        <subtask>Add required fields validation</subtask>
        <subtask>Add email format validation</subtask>
        <subtask>Add field completeness checking</subtask>
        <subtask>Return detailed error messages for failures</subtask>
        <subtask>Write unit tests for all validation scenarios</subtask>
      </task>
      
      <task id="4" title="Create Email Quality Checker" ac="AC-4">
        <subtask>Create utils/email_quality.py file</subtask>
        <subtask>Implement EmailQualityChecker class</subtask>
        <subtask>Add generic email pattern detection</subtask>
        <subtask>Add personal email indicator detection</subtask>
        <subtask>Return quality assessment with confidence score</subtask>
        <subtask>Write unit tests for quality checker</subtask>
      </task>
      
      <task id="5" title="Implement Bridge Service" ac="AC-1">
        <subtask>Create services/queue_bridge.py file</subtask>
        <subtask>Implement QueueBridgeService class</subtask>
        <subtask>Add aggregate_application_data() method (reads match + letter + scraped files)</subtask>
        <subtask>Add extract_contact_info() method (parses job details for email/name)</subtask>
        <subtask>Add send_to_queue() method (transforms and saves to pending/)</subtask>
        <subtask>Implement atomic file writes to prevent corruption</subtask>
        <subtask>Add comprehensive error handling</subtask>
        <subtask>Write unit tests for bridge service</subtask>
      </task>
      
      <task id="6" title="Update Job Matcher for Full URLs" ac="AC-2">
        <subtask>Open job_matcher.py</subtask>
        <subtask>Import URLNormalizer utility</subtask>
        <subtask>Update match dictionary creation to store full URLs</subtask>
        <subtask>Use URLNormalizer.to_full_url() for all application_url fields</subtask>
        <subtask>Test matcher with sample job data</subtask>
        <subtask>Verify match JSON contains full URLs</subtask>
      </task>
      
      <task id="7" title="Update Letter Generator for URL Storage" ac="AC-2">
        <subtask>Open motivation_letter_routes.py or letter_generation_utils.py</subtask>
        <subtask>Add application_url field to letter JSON structure</subtask>
        <subtask>Add job_title field to letter JSON for matching</subtask>
        <subtask>Ensure URL is stored during letter generation</subtask>
        <subtask>Test letter generation with URL storage</subtask>
        <subtask>Verify letter JSON contains application_url</subtask>
      </task>
      
      <task id="8" title="Create Bridge Route" ac="AC-1, AC-3, AC-5">
        <subtask>Open blueprints/job_matching_routes.py</subtask>
        <subtask>Create new route /job_matching/send_to_queue (POST)</subtask>
        <subtask>Accept match_file and selected_indices parameters</subtask>
        <subtask>Call QueueBridgeService to process selections</subtask>
        <subtask>Implement duplicate detection logic</subtask>
        <subtask>Return success/error JSON response</subtask>
        <subtask>Add error logging for debugging</subtask>
      </task>
      
      <task id="9" title="Update Results Page UI" ac="AC-3, AC-4, AC-5">
        <subtask>Open results page template (templates/results.html)</subtask>
        <subtask>Add "Send to Queue" button with icon</subtask>
        <subtask>Add multi-select checkboxes for each job match</subtask>
        <subtask>Add "Select All" / "Deselect All" helper buttons</subtask>
        <subtask>Show "Already has letter" indicator (green checkmark icon)</subtask>
        <subtask>Add loading spinner during bridge operation</subtask>
      </task>
      
      <task id="10" title="Implement Results Page JavaScript" ac="AC-3, AC-4, AC-5">
        <subtask>Create or update static/js/results.js (or add to main.js)</subtask>
        <subtask>Implement checkbox selection logic</subtask>
        <subtask>Implement AJAX call to /send_to_queue route</subtask>
        <subtask>Show email input modal when extraction fails</subtask>
        <subtask>Show duplicate warning dialog before queuing</subtask>
        <subtask>Display success toast with count and link to queue</subtask>
        <subtask>Display specific error messages on failure</subtask>
        <subtask>Handle loading states and disable buttons during operation</subtask>
      </task>
      
      <task id="11" title="Data Migration Script" ac="AC-2">
        <subtask>Create scripts/migrate_urls_to_full.py</subtask>
        <subtask>Read all existing job_matches_*.json files</subtask>
        <subtask>Convert relative URLs to full URLs using URLNormalizer</subtask>
        <subtask>Backup original files before modification</subtask>
        <subtask>Write updated files with full URLs</subtask>
        <subtask>Add url_migrated: true flag to modified matches</subtask>
        <subtask>Log migration results</subtask>
        <subtask>Document migration process in script comments</subtask>
      </task>
      
      <task id="12" title="Integration Testing" ac="All">
        <subtask>Create tests/test_queue_bridge.py</subtask>
        <subtask>Test complete bridge workflow (match → letter → queue)</subtask>
        <subtask>Test URL normalization and matching</subtask>
        <subtask>Test email extraction and quality checking</subtask>
        <subtask>Test duplicate detection</subtask>
        <subtask>Test validation error handling</subtask>
        <subtask>Test with missing data scenarios</subtask>
        <subtask>Test with malformed data scenarios</subtask>
        <subtask>Ensure all tests pass</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-1" title="Data Bridge Implementation">
      <requirement>Create bridge service that aggregates match + letter + scraped data</requirement>
      <requirement>Extract recipient email and name from job details</requirement>
      <requirement>Transform combined data into queue application JSON format</requirement>
      <requirement>Generate unique collision-free application IDs using UUID</requirement>
      <requirement>Save queue applications to job_matches/pending/ directory</requirement>
      <requirement>Handle missing data gracefully with clear error messages</requirement>
    </criterion>
    
    <criterion id="AC-2" title="URL Consistency">
      <requirement>Create centralized URLNormalizer utility class</requirement>
      <requirement>Store full URLs (not relative paths) in match JSON</requirement>
      <requirement>Add application_url field to letter JSON during generation</requirement>
      <requirement>Implement normalized URL comparison for matching</requirement>
      <requirement>Fallback to job ID extraction when URL comparison fails</requirement>
    </criterion>
    
    <criterion id="AC-3" title="Results Page Integration">
      <requirement>Add "Send to Queue" button on job matching results page</requirement>
      <requirement>Implement multi-select checkboxes for job selection</requirement>
      <requirement>Show "Already has letter" indicator for jobs with existing letters</requirement>
      <requirement>Display clear success/error messages after queuing</requirement>
      <requirement>Link from success message to queue dashboard</requirement>
    </criterion>
    
    <criterion id="AC-4" title="Email Extraction and Fallback">
      <requirement>Implement automatic email extraction from scraped job data</requirement>
      <requirement>Detect generic emails (jobs@, hr@, careers@) and show warnings</requirement>
      <requirement>Provide manual email input fallback when extraction fails</requirement>
      <requirement>Validate email format before queuing</requirement>
      <requirement>Store email quality assessment with application</requirement>
    </criterion>
    
    <criterion id="AC-5" title="Duplicate Detection">
      <requirement>Check pending queue for existing applications (same company + title)</requirement>
      <requirement>Show warning dialog before queuing duplicates</requirement>
      <requirement>Allow user to confirm or cancel duplicate submissions</requirement>
      <requirement>Log duplicate attempts for user awareness</requirement>
    </criterion>
    
    <criterion id="AC-6" title="Required Field Validation">
      <requirement>Validate all required fields before creating queue file</requirement>
      <requirement>Required: id, job_title, company_name, subject_line, motivation_letter, application_url, status</requirement>
      <requirement>Recommended: recipient_email, recipient_name</requirement>
      <requirement>Fail fast with specific error messages for missing fields</requirement>
      <requirement>Prevent silent failures from incomplete data</requirement>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PROBLEM-ANALYSIS-FINAL-2025-10-16.md</path>
        <title>Problem Analysis - Complete Analysis & Solutions</title>
        <section>Issue #1: Missing Data Bridge (CRITICAL)</section>
        <snippet>No code exists to transform match results + motivation letters into queue application format. The system has TWO SEPARATE DATA STRUCTURES that never get merged.</snippet>
      </doc>
      
      <doc>
        <path>docs/PROBLEM-ANALYSIS-FINAL-2025-10-16.md</path>
        <title>Problem Analysis - Complete Analysis & Solutions</title>
        <section>Issue #2: URL Matching Failures (MEDIUM)</section>
        <snippet>Match JSON stores relative paths (/job/title/123) while letter generator saves full URLs, causing URL normalization to fail when trying to match.</snippet>
      </doc>
      
      <doc>
        <path>docs/PROBLEM-ANALYSIS-FINAL-2025-10-16.md</path>
        <title>Problem Analysis - FMEA Critical Risks</title>
        <section>Race Conditions (Risk Score: 360)</section>
        <snippet>If clicking "Send to Queue" rapidly for multiple jobs, applications can be lost silently. Both use same timestamp ID → Second overwrites first. FIX: Use UUID-based IDs instead of timestamps.</snippet>
      </doc>
      
      <doc>
        <path>docs/ARCHITECTURE-REVIEW-QUEUE-INTEGRATION-2025-10-16.md</path>
        <title>Architecture Review - Bridge Design Assessment</title>
        <section>Architectural Pattern: Adapter/Transformer</section>
        <snippet>The bridge component is the correct architectural solution. Keeps matcher, letter generator, and queue as independent, single-purpose components. Testability: Bridge can be tested in isolation with mock data.</snippet>
      </doc>
      
      <doc>
        <path>docs/ARCHITECTURE-REVIEW-QUEUE-INTEGRATION-2025-10-16.md</path>
        <title>Architecture Review - Data Structure Strategy</title>
        <section>Intermediate Format: ApplicationContext Object</section>
        <snippet>Create a transient data structure for the bridge using @dataclass. Combines all sources (match, letter, scraped) with type safety and clear field mappings.</snippet>
      </doc>
      
      <doc>
        <path>docs/ARCHITECTURE-REVIEW-QUEUE-INTEGRATION-2025-10-16.md</path>
        <title>Architecture Review - URL Consistency Strategy</title>
        <section>Centralized URL Service</section>
        <snippet>Create utils/url_utils.py with URLNormalizer class. Architectural Principle: Single Source of Truth for URL handling. Store full URLs at data entry (Matcher), use normalized comparison for matching.</snippet>
      </doc>
      
      <doc>
        <path>Documentation/Stories/story-1.1.md</path>
        <title>Story 1.1 - Backend Infrastructure</title>
        <section>Dependency</section>
        <snippet>Story 1.1 implemented email sender and validation modules. EmailSender class provides send_application() method. ApplicationValidator provides validate_application() method. Both are COMPLETED and TESTED.</snippet>
      </doc>
      
      <doc>
        <path>Documentation/Stories/story-1.2.md</path>
        <title>Story 1.2 - Application Queue UI</title>
        <section>Dependency</section>
        <snippet>Story 1.2 implemented queue dashboard UI. Queue expects applications in job_matches/pending/*.json format. UI displays validation status and provides send functionality. COMPLETED.</snippet>
      </doc>
    </docs>
    
    <code>
      <artifact>
        <path>job_matcher.py</path>
        <kind>service</kind>
        <symbol>match_jobs_with_cv</symbol>
        <lines>148-195</lines>
        <reason>Produces match JSON files. NEEDS UPDATE: Currently stores relative URLs in 'application_url' field (line 179). Must be updated to store full URLs using URLNormalizer.</reason>
      </artifact>
      
      <artifact>
        <path>job_matcher.py</path>
        <kind>service</kind>
        <symbol>generate_report</symbol>
        <lines>212-260</lines>
        <reason>Generates match report with URL formatting. Shows current URL handling logic. Lines 246-252 demonstrate URL transformation attempts - this logic should be centralized in URLNormalizer.</reason>
      </artifact>
      
      <artifact>
        <path>blueprints/application_queue_routes.py</path>
        <kind>route</kind>
        <symbol>_load_applications</symbol>
        <lines>45-87</lines>
        <reason>Loads queue applications from pending/sent/failed folders. Expects specific JSON structure with required fields. Bridge must produce files matching this expected format.</reason>
      </artifact>
      
      <artifact>
        <path>blueprints/application_queue_routes.py</path>
        <kind>route</kind>
        <symbol>send_application</symbol>
        <lines>128-213</lines>
        <reason>Sends individual application via email. Shows required fields: recipient_email, recipient_name, subject_line, motivation_letter, job_title, company_name. Bridge output must include all these fields.</reason>
      </artifact>
      
      <artifact>
        <path>utils/validation.py</path>
        <kind>utility</kind>
        <symbol>ApplicationValidator</symbol>
        <lines>N/A</lines>
        <reason>COMPLETED in Story 1.1. Provides validate_application() method. Used by queue routes to validate applications before sending. Bridge should use same validator.</reason>
      </artifact>
      
      <artifact>
        <path>utils/email_sender.py</path>
        <kind>utility</kind>
        <symbol>EmailSender</symbol>
        <lines>N/A</lines>
        <reason>COMPLETED in Story 1.1. Provides send_application() method for sending emails via SMTP. Takes recipient_email, subject, motivation_letter, etc. Bridge ensures data ready for this interface.</reason>
      </artifact>
      
      <artifact>
        <path>blueprints/job_matching_routes.py</path>
        <kind>route</kind>
        <symbol>view_results</symbol>
        <lines>N/A</lines>
        <reason>NEEDS NEW ROUTE: Add /send_to_queue route to this blueprint. Will call bridge service to transform selected matches into queue applications. Must handle multi-select, duplicate detection, error responses.</reason>
      </artifact>
      
      <artifact>
        <path>templates/results.html</path>
        <kind>template</kind>
        <symbol>N/A</symbol>
        <lines>N/A</lines>
        <reason>NEEDS UPDATE: Add "Send to Queue" button, multi-select checkboxes, "Already has letter" indicators. JavaScript to call new /send_to_queue route with selected indices.</reason>
      </artifact>
    </code>
    
    <dependencies>
      <python>
        <package name="flask" version="3.1.0">Web framework - used for routes and blueprints</package>
        <package name="werkzeug" version="3.1.3">WSGI utility - provides secure_filename for file operations</package>
        <package name="email-validator" version="2.1.0">Email validation - use for validating recipient emails</package>
        <package name="python-dotenv" version="1.1.0">Environment variables - for SMTP configuration</package>
        <package name="pytest" version="8.0.0">Testing framework - for unit and integration tests</package>
        <package name="pytest-cov" version="4.1.0">Test coverage - ensure >90% coverage for new code</package>
      </python>
      
      <builtin>
        <module name="uuid">Generate unique collision-free application IDs</module>
        <module name="json">Read/write application JSON files</module>
        <module name="pathlib">File path operations with Path objects</module>
        <module name="datetime">Timestamp creation (created_at, sent_at fields)</module>
        <module name="logging">Error and operation logging</module>
        <module name="urllib.parse">URL parsing and normalization</module>
        <module name="shutil">File backup operations for migration script</module>
        <module name="tempfile">Atomic file writes using temporary files</module>
      </builtin>
    </dependencies>
  </artifacts>

  <constraints>
    <architectural>
      <constraint>Use Adapter/Transformer pattern for bridge - maintains separation of concerns</constraint>
      <constraint>Keep separate data schemas for matcher, letter generator, and queue - do NOT unify schemas</constraint>
      <constraint>Use ApplicationContext as transient data structure during transformation only</constraint>
      <constraint>Centralize URL handling in single service (URLNormalizer) - Single Source of Truth principle</constraint>
      <constraint>Abstract storage layer even while using file-based storage for easy future migration to database</constraint>
      <constraint>Implement fail-fast validation to prevent silent failures</constraint>
    </architectural>
    
    <technical>
      <constraint>CRITICAL: Use UUID-based IDs (uuid.uuid4()) - prevents race conditions from timestamp collisions</constraint>
      <constraint>CRITICAL: Validate all required fields before creating queue file - prevents silent failures</constraint>
      <constraint>CRITICAL: Warn on generic emails (jobs@, hr@, careers@) - prevents 30-70% failure rate</constraint>
      <constraint>Store FULL URLs everywhere (not relative paths) - enables consistent URL matching</constraint>
      <constraint>Implement atomic file writes using tempfile to prevent corruption during concurrent operations</constraint>
      <constraint>File operations must handle encoding='utf-8' and ensure_ascii=False for international characters</constraint>
    </technical>
    
    <testing>
      <constraint>Unit test coverage >90% for new code (URL utils, bridge service, validators)</constraint>
      <constraint>Integration tests must cover complete workflow: match → letter → queue</constraint>
      <constraint>Test error scenarios: missing data, malformed JSON, failed email extraction</constraint>
      <constraint>All tests must pass before marking story complete</constraint>
    </testing>
    
    <dataflow>
      <constraint>Match JSON → Letter JSON → Scraped Data JSON → Bridge aggregates → Queue Application JSON</constraint>
      <constraint>Bridge is READ-ONLY for matcher/letter data - never modifies source files</constraint>
      <constraint>Queue files created atomically in job_matches/pending/ directory</constraint>
      <constraint>Failed transformations logged with specific error messages - no silent failures</constraint>
    </dataflow>
  </constraints>

  <interfaces>
    <interface>
      <name>URLNormalizer</name>
      <kind>Utility Class</kind>
      <signature>
class URLNormalizer:
    @staticmethod
    def to_full_url(url: str, base_url: str = "https://www.ostjob.ch") -> str
    
    @staticmethod
    def normalize_for_comparison(url: str) -> str
    
    @staticmethod
    def extract_job_id(url: str) -> Optional[str]
      </signature>
      <path>utils/url_utils.py</path>
    </interface>
    
    <interface>
      <name>ApplicationContext</name>
      <kind>DataClass</kind>
      <signature>
@dataclass
class ApplicationContext:
    # From Match
    job_title: str
    company_name: str
    application_url: str
    match_score: int
    cv_path: str
    
    # From Letter
    subject_line: str
    letter_html: str
    email_text: Optional[str]
    
    # From Scraped Data
    contact_person: Optional[str]
    recipient_email: Optional[str]
    
    def to_queue_application(self) -> dict
      </signature>
      <path>models/application_context.py</path>
    </interface>
    
    <interface>
      <name>QueueBridgeService</name>
      <kind>Service Class</kind>
      <signature>
class QueueBridgeService:
    def aggregate_application_data(
        self, 
        match_file: Path, 
        selected_indices: List[int]
    ) -> List[ApplicationContext]
    
    def extract_contact_info(
        self,
        scraped_data: dict
    ) -> tuple[Optional[str], Optional[str]]
    
    def send_to_queue(
        self,
        contexts: List[ApplicationContext],
        dry_run: bool = False
    ) -> dict
      </signature>
      <path>services/queue_bridge.py</path>
    </interface>
    
    <interface>
      <name>EmailQualityChecker</name>
      <kind>Utility Class</kind>
      <signature>
class EmailQualityChecker:
    GENERIC_PATTERNS = ['jobs@', 'hr@', 'careers@', 'recruiting@']
    
    @classmethod
    def assess_email(cls, email: str) -> dict:
        # Returns: {
        #   'is_generic': bool,
        #   'confidence': float,
        #   'recommendation': str,
        #   'severity': str
        # }
      </signature>
      <path>utils/email_quality.py</path>
    </interface>
    
    <interface>
      <name>/job_matching/send_to_queue</name>
      <kind>REST Endpoint (POST)</kind>
      <signature>
Request JSON:
{
  "match_file": "job_matches_20251016.json",
  "selected_indices": [0, 2, 5]
}

Response JSON (success):
{
  "success": true,
  "queued": 3,
  "failed": 0,
  "errors": [],
  "warnings": ["Job 2: Generic email detected"]
}

Response JSON (failure):
{
  "success": false,
  "message": "Error description",
  "details": {...}
}
      </signature>
      <path>blueprints/job_matching_routes.py</path>
    </interface>
    
    <interface>
      <name>Queue Application JSON Format</name>
      <kind>Data Structure</kind>
      <signature>
{
  "id": "app-{uuid}",
  "job_title": "Product Owner",
  "company_name": "WILHELM AG",
  "recipient_email": "hr@wilhelm.ch",
  "recipient_name": "HR Team",
  "subject_line": "Bewerbung als Product Owner",
  "motivation_letter": "<html>...</html>",
  "application_url": "https://www.ostjob.ch/job/product-owner/1032053",
  "match_score": 8,
  "created_at": "2025-10-16T18:00:00",
  "status": "pending",
  "requires_manual_email": false
}
      </signature>
      <path>job_matches/pending/*.json</path>
    </interface>
    
    <interface>
      <name>Match JSON Format (Current)</name>
      <kind>Data Structure</kind>
      <signature>
{
  "job_title": "Product Owner",
  "company_name": "WILHELM AG",
  "application_url": "/job/product-owner/1032053",  // NEEDS UPDATE to full URL
  "overall_match": 8,
  "skills_match": 9,
  "location": "St. Gallen",
  "cv_path": "input/Lebenslauf.pdf"
}
      </signature>
      <path>job_matches/job_matches_*.json</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      The project uses pytest for testing with >90% coverage requirement for new code. Tests are organized in tests/ directory with naming convention test_*.py. Use fixtures for common test data. Mock external dependencies (file system, APIs). Follow AAA pattern (Arrange, Act, Assert). Integration tests should cover complete workflows. All tests must pass before story completion.
    </standards>
    
    <locations>
      <location>tests/test_queue_bridge.py - Integration tests for complete bridge workflow</location>
      <location>tests/test_url_utils.py - Unit tests for URLNormalizer class</location>
      <location>tests/test_application_context.py - Unit tests for ApplicationContext transformation</location>
      <location>tests/test_email_quality.py - Unit tests for EmailQualityChecker</location>
      <location>tests/test_job_matching_routes.py - Route tests for /send_to_queue endpoint</location>
    </locations>
    
    <ideas>
      <idea ac="AC-1" title="Bridge Service Integration Test">
        Test complete workflow: Load match JSON → Find letter JSON → Load scraped data → Aggregate into ApplicationContext → Transform to queue format → Save to pending/ → Verify file created with correct structure
      </idea>
      
      <idea ac="AC-2" title="URL Normalization Test">
        Test URLNormalizer with various formats: relative paths (/job/title/123), full URLs (https://www.ostjob.ch/job/title/123), URLs with trailing slashes, URLs with www vs without. Verify to_full_url() and normalize_for_comparison() handle all cases correctly.
      </idea>
      
      <idea ac="AC-3" title="Results Page UI Test">
        Test JavaScript checkbox selection, AJAX call to /send_to_queue, success message display, error handling, loading states. Use Selenium or Playwright for browser automation testing.
      </idea>
      
      <idea ac="AC-4" title="Email Extraction Test">
        Test EmailQualityChecker with various email formats: generic (jobs@, hr@), personal (john.doe@), missing email. Verify warnings shown for generic emails, fallback to manual input when missing.
      </idea>
      
      <idea ac="AC-5" title="Duplicate Detection Test">
        Create two applications with same company_name + job_title → Verify duplicate detected → Test user confirmation flow → Ensure both saved if confirmed
      </idea>
      
      <idea ac="AC-6" title="Validation Failure Test">
        Test ApplicationValidator with missing required fields (id, job_title, recipient_email) → Verify specific error messages → Ensure no queue file created on validation failure
      </idea>
      
      <idea ac="ALL" title="Race Condition Test">
        Test UUID-based ID generation: Rapidly create multiple applications → Verify all have unique IDs → No overwrites or collisions
      </idea>
      
      <idea ac="ALL" title="Error Recovery Test">
        Test with malformed JSON, missing files, invalid data types → Verify graceful error handling → Specific error messages logged → No silent failures
      </idea>
    </ideas>
  </tests>
</story-context>
